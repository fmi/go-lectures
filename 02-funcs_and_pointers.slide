Функции и указатели
13.02.2017

fmi@golang.bg
http://fmi.golang.bg/

* Funcs 101

- Функциите са основна структурна единица в Go
- Всеки проблем, който някога ще решавате, ще е разбит на функции
- Една функция върши точно едно нещо
- ... в противен случай правите нещо грешно
- Може да връща няколко резултата
- Последните три точки не си противоречат взаимно
- DRY
- Редът, в който са дефинирани, не е от значение
- Може и да изпада в паника (буквално)


* С ключовата дума func могат да се създават три неща

1. Функции

2. Ламбди

3. Методи


* Функции

.play code/funcs_and_pointers/simple_funcs.go

* Аргументи

    func foo(a int, b string) float64

Функцията foo приема int и string и връща float64

- Винаги работим върху копия от аргументите
- Ако това не ни устройва, подаваме указател (за тях след малко)
- Нямаме стойности по подразбиране (optional parameters) или overloading

Когато няколко аргумента са от един тип:

    func bar(a, b int, c float64) float64

* Произволен брой аргументи

    func sum(args ...int) int

Функцията sum приема произволен брой числа и връща техния сбор

.code code/funcs_and_pointers/lots_of_arguments.go /^func sum/,/^}/

Извикваме я с колкото ни трябват

    sum()           //0
    sum(2, 3)       //5
    sum(2, 3, 4, 5) //14

Трябва да е последния аргумент на функцията
* Следващата лекция ще говорим по-подробно за `range`

* Множество стойности като резултат

.play code/funcs_and_pointers/many_results.go

* Защо?

- Няма нуждата от някои грозни C идиоми, като ...
- ... модифициране на аргумент, подаден по адрес
- ... errno
- По-лесно справяне с грешки


* Как е реализирано в "стари" езици:

- C/C++ и компания: масив или структура
- Python: tuple-и

* Как е реализирано в Go?
- Много просто: връщате каквото ви трябва

* Ами ако не ни трябват всичките резултати?

1. Знаем, че ако дефинираме променлива и не я използваме, гърми
2. Ако искаме онзи сбор и не ни интересува броят аргументи, това ще изгърми

    result, count := sumAndCount(2, 3, 4, 5)

3. Ако нямаме нужда от дадена стойност, я присвояваме на _:

    result, _ := sumAndCount(2, 3, 4, 5)

- Тя не се запазва и не можем да я достъпим след това
- По-полезно е отколкото ви се струва


* Именовани резултати

.code code/funcs_and_pointers/named_sum_and_count.go /^func sum/,/^}/

- Резултатите се инициализират преди изпълнението на функцията
- Добра идея са, ако пишем често в тях по време на изпълнение
- Няма нужда да ги указваме при return

* Фунцкиите като стойности

- В реда на нещата е функция да приема функция

.code code/funcs_and_pointers/as_values.go /^func foo/,/^}/

- Няма нищо лошо в това и да връщаме функция

.code code/funcs_and_pointers/as_values.go /^func createRandomGenerator/,/^}/

- Въобще, можем да ги присвояваме на стойност
- Но можем да ги сравняваме само с `nil`

* Имаме си и нормална рекурсия
.play code/funcs_and_pointers/factorial.go /^func factorial/,/^}/


* Именоване на функции

- Кратки, описателни имена
- Започва с буква, последвана от букви, цифри или _
- Помните ли, че тук всеки стринг е UTF-8?
- `ЗнаетеЛиЧеHelloWorldНаКитайскиЕ世界` е валидно име на функция
- *НЕ* пишете такива имена!
- camelCase
- Ако функцията ни трябва извън текущия пакет: CamelCase


* Анонимни функции

  func(x, y int) int { return x * y }

- НЕ можем да дефинираме нормална функция в тялото на друга.
- Но пък можем да създаваме ламбди
- Ламбдите си нямат име... очевидно
- Удобни са за дребни неща

.play code/funcs_and_pointers/lambdas.go /^func main/,/^}/

* Scope, visibility & escape analysis

.play code/funcs_and_pointers/visibility.go

Променливата `count` нужна ли е въобще?

* defer

- `defer` е специален механизъм на езика
- `defer` добавя *извикване* на функция в един списък (стек)
- Когато обграждащата функция приключи, тези извиквания се изпълняват в обратен ред

.play code/funcs_and_pointers/defer_example_0.go

* Пример:

    func CopyFile(dstName, srcName string) (written int64, err error) {
        src, err := os.Open(srcName)
        if err != nil {
            return
        }

        dst, err := os.Create(dstName)
        if err != nil {
            return
        }

        written, err = io.Copy(dst, src)
        dst.Close()
        src.Close()
        return
    }

Какви са проблемите с този код?


* По-красивият, правилен и работещ начин е това:

    func CopyFile(dstName, srcName string) (written int64, err error) {
        src, err := os.Open(srcName)
        if err != nil {
            return
        }
        defer src.Close()

        dst, err := os.Create(dstName)
        if err != nil {
            return
        }
        defer dst.Close()

        return io.Copy(dst, src)
    }

`defer` се използва за сигурно и лесно почистване на ресурси (отворени файлове, заключени `mutex-и`, etc.)

* Доуточнения

- `defer` statement-ите ни позволяват да мислим за затварянето на файловете веднага след отварянето им
- Това ни гарантира, че няма да забравим в никой случай за затварянето им, независимо кой, кога и как променя кода след нас

* Три прости правила за defer (1)

- Аргументите на `defer` се оценяват, когато самият `defer` statement се оценява

    func a() {
        i := 0
        defer fmt.Println(i)
        i++
        return
    }

- Това принтира "0"

* Три прости правила за defer (2)

- Функциите се изпълняват в `LIFO` ред

    func b() {
        for i := 0; i < 4; i++ {
            defer fmt.Print(i)
        }
    }

- Това изписва "3210"

* Три прости правила за defer (3)

- `defer` -натите функции могат да "пипат" по именованите връщани аргументи на обграждащата функция

    func c() (i int) {
        defer func() { i++ }()
        return 1
    }

- Тази функция връща "2"
- Това е удобно, за да променяме връщаните стойности от функции, примерно за да върнем грешка

* Примери

.play code/funcs_and_pointers/defer_example1.go /^func deferExample/,/^}/

-

.play code/funcs_and_pointers/defer_example2.go /^func deferExample/,/^}/

* Методи

За тях ще си говорим като стигнем до дефиниране на типове


* Указатели

* Указатели
.image assets/armed.jpg

- Особен момент е, че нямаме аритметиката с указатели
- Ако знаете как да ги ползвате в C/C++, нямате ядове

* За останалите: Опреснителен курс

- Всички променливи, константи и функции се пазят в оперативната памет
- Всяка запазена стойност стои в отделна клетка
- Всяка клетка си има уникален адрес (0xb6802, 0xfx04001d7f0)
- За да вземем адреса на дадена променлива, използваме унарния оператор `&`
- Имаме тип указател: `*int`
- Указателите са с константна големина
- Указател може да сочи към указател
- В Go една стойност се изчиства от паметта когато няма указатели към нея
- Не можем да имаме указатели към константи
- Очевидно `intP`==`*(&intP)`

* Пример

.play code/funcs_and_pointers/pointers.go

* Как да си направим дупка в крака?

.play code/funcs_and_pointers/broken_pointer.go

* Указатели и функции

    func foo(a int, b *string) float64

Функцията foo приема int и *указател* към string и връща float64

Демек `a` бива копиран в скоупа на `foo`, а `b` просто сочи към някаква стойност отвън.

- `b` не се копира. Ако в него има около 652183859 символа*, това е предимство
- Каквото и да правим с `a` не влияе на нищо извън тази функция
- Каквото и да направим с `b` променяме оригиналната стойност
_*Следващата_лекция_ще_видим_защо_указател_към_string_може_да_не_ни_спести_кой-знае_колко_памет_
