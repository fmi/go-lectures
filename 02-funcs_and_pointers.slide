Функции и указатели
08.10.2013

http://play.golang.org/

fmi@golang.bg
http://fmi.golang.bg/
@fmi_golang

* Но преди това...


* Въпрос за мъфин #1

В кои случаи дадена променлива е достъпна извън пакета, в който е дефинирана?

- Когато името ѝ започва с главна буква


* Въпрос за мъфин #2

Кога обединяваме дефиницията на няколко променливи така

    var (
        name string = "Мъфинчо"
        age uint8 = 5
    )

вместо така

    var name string = "Мъфинчо"
    var age uint8 = 5

?

- Когато са свързани логически


* Въпрос за мъфин #3

Къде *НЕ* можем да ползваме `type-inference`?

- В глобалния скоуп


* Въпрос за мъфин #4

От какви типове може да бъде всяка константа?

- bool
- int
- float
- string
- complex


* Въпрос за мъфин #5

За какво се ползва ключовата дума `iota`?

- Дефиниране на `enum`


* Funcs 101

- Функциите са основна структурна единица в Go
- Всеки проблем, който някога ще решавате, ще е разбит на функции
- Една функция върши точно едно нещо
- ... в противен случай правите нещо грешно
- DRY
- Редът, в който са дефинирани, не е от значение
- Всяка функция може да връща 0 или повече резултати
- Може и да изпада в паника (буквално)


* func се използва за три неща в езика

1. Функции
2. Ламбди
3. Методи


* Подаване на аргументи

    func fоо(a int, b string) float

Функцията foo приема int и string и връща float

- Винаги работим върху копия от аргументите
- Ако това не ни устройва, подаваме указател (за тях след малко)


* Подаване на много аргументи

    func sum(args ...int) int

Функцията sum приема произволен брой числа и връща техният сбор

.code code/02/lots_of_arguments.go /^func sum/,/^}/


* Резултат от множество стойности

*** Как е реализирано в "стари" езици:
- C/C++ и компания: масив или структура
- Python: tuple-и

*** Как е реализирано в Go?
- Много просто: връщате каквото ви трябва

*** Защо?
- По-лесно log-ване на грешки
- Улеснява handle-ване на състояния

.play code/02/many_results.go /^func sum/,/^}/


* Ами ако не ни трябват всичките?

1. Знаем, че ако дефинираме променлива и не я използваме, гърми
2. Ако искаме онзи сбор и не ни интересува броят аргументи, това ще изгърми

    result, count := sumAndCount(2, 3, 4, 5)

3. Ако нямаме нужда от дадена стойност, я присвояваме на _:

    result, _ := sumAndCount(2, 3, 4, 5)

- Тя не се запазва и не можем да я достъпим след това
- По-полезно е отколкото ви се струва


* Именовани резултати

- Резултатите се инициализират преди изпълнението на функцията
- Добра идея са, ако пишем често в тях по време на изпълнение
- Няма нужда да ги указваме при return
- Иначе не са нищо особено
- Дори няма да ги ползвате често

.play code/02/named_sum_and_count.go /^func sum/,/^}/


* Fun facts

- В реда на нещата е функция да приема функция
- Няма нищо лошо в това и да връщаме функция
- Въобще, можем да ги присвояваме на стойност и сравняваме с други
- Дори може да върне себе си

* ...или да изпълни себе си
.play code/02/factorial.go /^func factorial/,/^}/


* Именоване на функции

- Кратки, описателни имена
- Започва с буква, последвана от букви, цифри или _
- Помните ли, че тук всеки стринг е UTF-8?
- `ЗнаетеЛиЧеHelloWorldНаКитайскиЕ世界` е валидно име на функция
- *НЕ* пишете такива имена!
- camelCase
- Ако функцията ни трябва извън текущия пакет: CamelCase


* Анонимни функции


* func(x, y int) int { return x + y }

- НЕ можем да дефинираме нормална функция в тялото на друга.
- Ламбдите си нямат име... очевидно
- Удобни са за дребни неща

.play code/02/lambdas.go /^func main/,/^}/


* Методи

За тях ще си говорим, като стигнем до дефиниране на типове


* Указатели

* Указатели
.image assets/armed.jpg

- Особен момент е, че нямаме аритметиката с указатели
- Ако знаете как да ги ползвате в C/C++, нямате ядове

* За останалите: Опреснителен курс

- Всички променливи, константи и функции се пазят в оперативната памет
- Всяка запазена стойност стои в отделна клетка
- Всяка клетка си има уникален адрес (0xb6802, 0xfx04001d7f0)
- За да вземем адреса на дадена променлива, използваме унарния оператор `&`
- Имаме тип указател: `*int`
- Указателите са с константна големина
- Указател може да сочи към указател, който да сочи към стойност
- Една стойност се изчиства от паметта, едва когато няма указатели към нея
- Не можем да имаме указатели към константи
- Очевидно `intP`==`*(&intP)`

* Пример

.play code/02/pointers.go

* Как да си направим дупка в крака?

.play code/02/broken_pointer.go

* Указатели и функции

    func fоо(a int, b *string) float

Функцията foo приема int и *указател* към string и връща float

Демек `a` бива копиран в скоупа на `foo`, а `b` просто сочи към някаква стойност отвън.

- `b` не се копира. Ако в него има около 652183859 символа, това е предимство
- Каквото и да правим с `a` не влияе на нищо извън тази функция
- Каквото и да направим с `b` променяме оригиналната стойност
